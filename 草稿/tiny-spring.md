BeanDefinition存储了bean对象
BeanFactory存储了name-》bean对象的键值对

PointcutAdvisor 获取pointcut和Advice的接口，获取哪个位置，哪个通知，换言之对哪个方法做增强
AspectJExpressionPointcutAdvisor获取AspectJExpressionPointcut和advice

通知相关：
Advisor 获取Advice的接口
Advice通知，比MethodInterceptor更抽象，MethodInterceptor是更具体的接口
MethodInterceptor代理逻辑，可以看成是装饰器


位置相关：
Pointcut定义切点，获得判断类、方法匹不匹配的对象
AspectJExpressionPointcut通过AspectJExpression实现的pointcut
MethodMatcher判断方法匹配
ClassFilter判断类匹配

代理相关：
MethodInvocation定义方法调用，可以看作是java中传递一个函数的封装
ReflectiveMethodInvocation传递的是通过反射调用的函数封装
TargetSource定义哪个对象，包括对象实例，对象类型
AdvisedSupport代理的元信息，包含哪个对象，哪个方法，代理逻辑

整个流程是AspectJAwareAdvisorAutoProxyCreator完成的，它在bean实例化后对bean做处理。所有aop相关的元信息存储在AspectJExpressionPointcutAdvisor中，听记录了在哪个位置，哪个通知。通过匹配出需要处理的bean后，需要生成代理，这步会将需要的元信息放到AdvisedSupport中，包括哪个对象，哪个方法，哪个通知，


可以把MethodInterceptor看作装饰器，MethodInvocation看作函数

ApplicationContext作为beanFactory的静态代理，封装了读取配置文件，生成beanFactory的操作。首先从配置文件读取出所有bean信息，存储到beanFactory中，然后由ApplicationContext触发beanPostProcessor类型bean的生成，此时beanFactory中已经存储了所有的beanPostProcessor。当调用ApplicationContext的getBean时，首先创建bean，然后调用所有的beanPostProcessor对bean做处理，这一步是aop产生的地方。

aop的入口是AspectJAwareAdvisorAutoProxyCreator，它是一个beanPostProcessor，它会获取beanFactory中所有的AspectJExpressionPointcutAdvisor类型的bean，这些bean中存储了pointcut和advice，通过对bean和pointcut做比对，找到需要被代理的对象，生成代理


jdk代理比较清晰

cglib代理有点混乱


